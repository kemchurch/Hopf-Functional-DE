function [] = F_Hopf_build(f,DIM,DIM_PARA,FIXCOMP,ORDER)
% [] = F_Hopf_build(f,DIM,DIM_PARA,FIXCOMP,ORDER)
% Generates the map F for verfication of isolation and transversality
% conditions for Hopf bifurcation, as well as derivatives needed for radii
% polynomial. The Matlab functions F_Hopf, DF_Hopf, F_Hopf_Z2 and
% F_Hopf_Z2_Rem are saved to the \Data folder. 
% f: anonymous function of the form @(x,xtau,alpha,para), where para is a
% vector representing any fixed constants, alpha is the bifurcation
% parameter, x and xtau are the state and delayed state.
% DIM: dimension of the output of f.
% DIM_PARA: dimension of the parameter para.
% FIXCOMP: component 1,...,DIM that is fixed for the eigenvector isolation
% ORDER: -1,0,1,2.... order to use for the radii polynomial. Larger should
% give better isolation but take more time (symbolics are slow). Order -1
% corresponds to the "direct" bound Z_2 = sup ||A[DF(u0+delta)-DF(u0)||,
% and can outperform an ORDER 0 expansion for some problems.
% 
% ::METAPROGRAMMING OUTPUTS GENERATED BY SYMBOLIC TOOLBOX::
%
% F_Hopf(X,Re_FIXVAL,Im_FIXVAL,PARA,TAU)
% X=[x0;x0';alpha*;omega*;Re_v;Im_v;Re_lam';Im_lam';Re_v';Im_v'],
% where Re_v and Im_v are the remaining components that are NOT fixed by
% FIXCOMP.
% Re_FIXVAL and Im_FIXVAL: real/imaginary parts of the fixed eigenvector
% component with index FIXCOMP.
% PARA: numerical parameter vector.
% TAU: numerical delay.
%
% DF_Hopf(X,Re_FIXVAL,Im_FIXVAL,PARA,TAU)
% Uses the same input types as F_Hopf.
%
% Jacobian_0(x,xtau,alpha,PARA) and Jacobian_tau(x,xtau,alpha,PARA)
% x and xtau : vectors if dimension DIM
% alpha : bifurcation paramter
% PARA : numerical parameter vector
%
% Remaining function output files: used by the proof function
% prove_Hopf_isolation.
addpath('Data')
% Initialize symbols
X = sym('X',[6*DIM,1],'real');          %6n-dimensional state vector
x = X(1:DIM);                           %Symbolic zero
x_tau = sym('x_tau',[DIM,1],'real');    %Symbolic x_tau
xx = X(DIM+1:2*DIM);                    %Zero derivative
a = X(2*DIM+1);                         %Parameter
omega = X(2*DIM+2);                     %imaginary part of eigenvalue at Hopf
Re_v = X(2*DIM+3:3*DIM+1);              %Real part of eigenvector
Im_v = X(3*DIM+2:4*DIM);                %Imaginary part of eigenvector
Re_LAM = X(4*DIM+1);                    %Real part eigenvalue derivative
Im_LAM = X(4*DIM+2);                    %Imaginary part eigenvalue derivative
Re_vv = X(4*DIM+3:5*DIM+1);             %Real part eigenvector derivative
Im_vv = X(5*DIM+2:6*DIM);               %Imaginary part eigenvector derivative
Re_FIXVAL = sym('Re_FIXVAL','real');    %Real part of v_FIXCOMP
Im_FIXVAL = sym('Im_FIXVAL','real');    %Imaginary part of v_FIXCOMP
PARA = sym('PARA',[DIM_PARA,1],'real'); %Symbolic vector for the constants
TAU = sym('TAU','real');                %Symbolic delay tau

% Some preprocessing
hv = [Re_v(1:FIXCOMP-1)+1i*Im_v(1:FIXCOMP-1);
    Re_FIXVAL + 1i*Im_FIXVAL;
    Re_v(FIXCOMP:DIM-1)+1i*Im_v(FIXCOMP:DIM-1)];
jvv = [Re_vv(1:FIXCOMP-1)+1i*Im_vv(1:FIXCOMP-1);
    0;
    Re_vv(FIXCOMP:DIM-1) + 1i*Im_vv(FIXCOMP:DIM-1)];
LAM = Re_LAM + 1i*Im_LAM;
fs = f(x,x_tau,a,PARA);    %symbolic version of f for jacobians
exp_tau = cos(omega*TAU)-1i*sin(omega*TAU);

% f=0 part
F1 = f(x,x,a,PARA); 
% eigenvector part
F2 = jacobian(fs,x)*hv ...
    + jacobian(fs,x_tau)*exp_tau*hv - 1i*omega*hv;
% eigenvalue variation part
F3 = jacobian(jacobian(fs,x)*xx,x)*hv ...
    + jacobian(jacobian(fs,x)*xx,x_tau)*exp_tau*hv...
    + jacobian(jacobian(fs,x_tau)*xx,x)*exp_tau*hv...
    + jacobian(jacobian(fs,x_tau)*xx,x_tau)*exp_tau*hv...'
    + jacobian(jacobian(fs,x)*hv,a)...
    + jacobian(jacobian(fs,x_tau)*exp_tau*hv,a)...
    + jacobian(fs,x_tau)*(-TAU)*exp_tau*LAM*hv...
    - LAM*hv + jacobian(fs,x)*jvv...
    + jacobian(fs,x_tau)*exp_tau*jvv - omega*jvv;
% implicit differentiation part for xx
F4 = jacobian(fs,x)*xx + jacobian(fs,x_tau)*xx...
    + jacobian(fs,a);
% processing the F map
concat_F = subs([F1;real(F2);imag(F2);real(F3);imag(F3);F4],x_tau,x);
matlabFunction(concat_F,'Vars',{X;Re_FIXVAL;Im_FIXVAL;PARA;TAU},...
    'Optimize',false,'file','Data\F_Hopf.m');
% generate Z2 data for expansion of specified ORDER
X0 = sym('X0',[6*DIM,1],'real');        %Taylor expansion point
DELTA = sym('DELTA',[6*DIM,1],'real');  %Arbitrary element of r-ball.
F = F_Hopf(X,Re_FIXVAL,Im_FIXVAL,PARA,TAU);
DF = jacobian(F,X);
if ORDER == -1
    Z2_TAYLOR = subs(DF,X,X0+DELTA)-subs(DF,X,X0);
    Z2_TAYLOR_REM = sym(0);
else
    DF_Taylor = sym(zeros(6*DIM,6*DIM));
    DF_Taylor_Rem = sym(zeros(6*DIM,6*DIM));
    for k=1:6*DIM
        if ORDER>0
            DF_Taylor(:,k) = taylor(DF(:,k),X,'order',ORDER+1,'ExpansionPoint',X0);
        end
        DF_Taylor_Rem(:,k) = taylor(DF(:,k),X,'order',ORDER+2,'ExpansionPoint',X0) - DF_Taylor(:,k);
    end
% Get DF(X0+DELTA)-DF(X0) and multiply through by symbolic factorial to
% avoid problems with non-representable reciprocal floats. Get the
% remainder and multiply by factorials too.
    Z2_TAYLOR = sym(factorial(ORDER))*(subs(DF_Taylor,X,X0+DELTA) - subs(DF,X,X0));
    Z2_TAYLOR_REM = sym(factorial(ORDER+1))*subs(DF_Taylor_Rem,X,X0+DELTA);
end
matlabFunction(DF,'Vars',{X;Re_FIXVAL;Im_FIXVAL;PARA;TAU},...
    'Optimize',false,'file','Data\DF_Hopf.m');
matlabFunction(Z2_TAYLOR,'Vars',{X0;DELTA;Re_FIXVAL;Im_FIXVAL;PARA;TAU},...
    'Optimize',false,'file','Data\F_Hopf_Z2.m');
matlabFunction(Z2_TAYLOR_REM,'Vars',{X0;DELTA;Re_FIXVAL;Im_FIXVAL;PARA;TAU},...
    'Optimize',false,'file','Data\F_Hopf_Z2_Rem.m');

% Jacobians for the non-resonance check
ff = f(x,x_tau,a,PARA);
Jacobian_0 = jacobian(ff,x);
Jacobian_tau = jacobian(ff,x_tau);
matlabFunction(Jacobian_0,'Vars',{x;x_tau;a;PARA},'Optimize',false,'file',...
    'Data\Jacobian_0.m');
matlabFunction(Jacobian_tau,'Vars',{x;x_tau;a;PARA},'Optimize',false,'file',...
    'Data\Jacobian_tau.m');

end